#!/usr/bin/env ruby

require "bundler/setup"
require "dotenv/load"
require "logger"
require "straddle"
require "date"
require "securerandom"

# -----------------------------
# LOGGER SETUP
# -----------------------------
LOG_FILE = "lifecycle.log"
log = Logger.new(LOG_FILE, "daily")
log.level = Logger::INFO
log.formatter = proc do |severity, datetime, progname, msg|
  "#{datetime.utc.iso8601} #{severity.ljust(5)}: #{msg}\n"
end

stdout_logger = Logger.new($stdout)
stdout_logger.level = Logger::INFO
stdout_logger.formatter = log.formatter

def log_and_puts(log, stdout_logger, msg, level = :info)
  log.send(level, msg)
  stdout_logger.send(level, msg)
end

def timestamp
  Time.now.strftime("%y%m%d%H%M")
end

def fail!(log, stdout_logger, msg)
  log_and_puts(log, stdout_logger, "❌  #{msg}", :error)
  exit(1)
end

# -----------------------------
# INITIALIZE CLIENT
# -----------------------------
client = Straddle::Client.new(
  api_key:     ENV.fetch("STRADDLE_API_KEY"),
  environment: ENV.fetch("STRADDLE_ENV", "sandbox").to_sym
)
 

begin


# # 1️⃣ Create Organization
log_and_puts(log, stdout_logger, "1️⃣  Creating an organization…")
org = client.send(
  :request,
  method: :post,
  path:   "/v1/organizations",
  body: {
    name:        "RubySDK Org #{timestamp}",
    external_id: "ruby_sdk_org_#{timestamp}",
    meta_data: {
      "created_via" => "RubySDK",
      "timestamp"   => timestamp
    }
  }
)[:data]
fail!(log, stdout_logger, "Org creation failed: #{org.inspect}") unless org[:id]
log_and_puts(log, stdout_logger, "   → Created org #{org[:id]} (name=#{org[:name]})")

# 2️⃣ Create Business Account under that Organization
log_and_puts(log, stdout_logger, "2️⃣  Creating an account for org #{org[:id]}…")
account = client.embed.accounts.create(
  organization_id: org[:id],
  account_type:    "business",
  business_profile: {
    name:        "RubySDK Co #{timestamp}",
    website:     "https://rubysdk-#{timestamp}.example.com",
    legal_name:  "RubySDK Corporation",
    description: "Generated by RubySDK at #{timestamp}",
    use_case:    "testing-sdk",
    tax_id:      "000000000",
    phone:       "+15555550123",
    address: {
      line1:       "123 SDK St",
      city:        "Testville",
      state:       "CA",
      postal_code: "94016",
      country:     "US"
    },
    industry: {
      mcc:      "7372",
      category: "Software Development",
      sector:   "Professional Services"
    }
  },
  access_level: "standard",
  external_id:  "ruby_sdk_acc_#{timestamp}",
  metadata:     { "sdk_test" => "true" }
).data
fail!(log, stdout_logger, "Account creation failed: #{account.inspect}") unless account[:id]
log_and_puts(
  log, stdout_logger,
  "   → Created account #{account[:id]} (status=#{account[:status]})"
)

 
log_and_puts(log, stdout_logger, "🔄  Checking capability statuses for account #{account.id}…")

resp = client.embed.accounts.get(account.id)
caps = resp.data[:capabilities][:customer_types]

log_and_puts(
  log, stdout_logger,
  "   → Capability statuses: " \
  "individuals=#{caps[:individuals][:capability_status]}, " \
  "businesses=#{caps[:businesses][:capability_status]}"
)
# 3️⃣ Create a new customer under that account
log_and_puts(log, stdout_logger, "3️⃣  Creating a customer for account #{account.id}…")

customer_payload = {
  name:        "RubySDK User #{timestamp}",
  type:        "individual",                             # or "business"
  email:       "ruby.user.#{timestamp}@example.com",
  phone:       "+11234567890",
  external_id: "cust_#{timestamp}",
  device:      { ip_address: "127.0.0.1" }
}

resp = client.send(
  :request,
  method:  :post,
  path:    "/v1/customers",
  body:    customer_payload,
  headers: { "Straddle-Account-Id" => account.id }
)

customer = resp[:data]
fail!(log, stdout_logger, "Customer creation failed: #{customer.inspect}") unless customer[:id]
log_and_puts(log, stdout_logger, "   → Created customer #{customer[:id]}")

# 4 Create Paykey via Bridge
log_and_puts(log, stdout_logger, "1️⃣  Creating bank-account paykey…")
paykey_payload = {
    customer_id:    customer[:id],
    routing_number: "021000018",
    account_number: "123456788",
    account_type:   "checking",
    metadata: {
      key1: "bank account #{rand(1000)}",
      key2: "acct-#{timestamp}"
    }
}

paykey = client.bridge.link.bank_account(paykey_payload).data
fail!(log, stdout_logger, "Paykey creation failed: #{paykey.inspect}") unless paykey&.id
log_and_puts(log, stdout_logger, "   → Created paykey #{paykey.id}")

# 5 Create Charge via low-level transport
log_and_puts(log, stdout_logger, "2️⃣  Creating a charge…")
charge_payload = {
    paykey:       paykey.paykey,
    description:  "RubySDK Subscription fee #{rand(100..999)}",
    amount:       rand(100..2000),
    currency:     "USD",
    payment_date: Date.today.to_s,
    consent_type: "internet",
    device:       { ip_address: "192.168.1.100", user_agent: "RubySDK/1.0" },
    external_id:  "ORDER#{rand(1000..9999)}",
    config:       { balance_check: "Disabled", sandbox_outcome: "paid" },
    meta_data:    { customer_type: "premium", promo_code: "PC#{timestamp}" }
}
raw_charge = client.send(
    :request,
    {
      method:  :post,
      path:    "/v1/charges",
      body:    charge_payload,
      headers: { "Straddle-Account-Id" => account.id }
    }
)
charge = raw_charge[:data]
fail!(log, stdout_logger, "Charge failed: #{charge.inspect}") unless charge[:id]
log_and_puts(
    log,
    stdout_logger,
    "   → Created charge #{charge[:id]} (status=#{charge[:status]}) - " \
    "description: #{charge[:description]}"
)

# 6 Create Payout via low-level transport
log_and_puts(log, stdout_logger, "3️⃣  Creating a payout…")
payout_payload = {
    paykey:       paykey.paykey,
    description:  "RubySDK Monthly subscription fee #{rand(100..999)}",
    amount:       charge[:amount],
    currency:     "USD",
    payment_date: Date.today.to_s,
    consent_type: "internet",
    device:       { ip_address: "192.168.1.100", user_agent: "RubySDK/1.0" },
    external_id:  "PAYOUT#{rand(1000..9999)}",
    config:       { balance_check: "Enabled", sandbox_outcome: "cancelled_for_balance_check" },
    meta_data:    { customer_type: "premium", promo_code: "PC#{timestamp}" }
}
raw_payout = client.send(
    :request,
    {
      method:  :post,
      path:    "/v1/payouts",
      body:    payout_payload,
      headers: { "Straddle-Account-Id" => account.id }
    }
)
payout = raw_payout[:data]
fail!(log, stdout_logger, "Payout failed: #{payout.inspect}") unless payout[:id]
log_and_puts(
    log,
    stdout_logger,
    "   → Created payout #{payout[:id]} (status=#{payout[:status]}) - " \
    "description: #{payout[:description]}"
)

# 7 List Payments for this account (only yours)
log_and_puts(log, stdout_logger, "4️⃣  Listing recent payments for account…")
raw_payments = client.send(
    :request,
    {
      method:  :get,
      path:    "/v1/payments",
      query:   { limit: 20 },
      headers: { "Straddle-Account-Id" => account.id }
    }
)
payments = raw_payments[:data]
sdk_payments = payments.select { |p| p[:description].include?("RubySDK") }
fail!(log, stdout_logger, "No RubySDK payments found") if sdk_payments.empty?
sdk_payments.each do |p|
    log_and_puts(
      log,
      stdout_logger,
      "   • Payment #{p[:id]}: #{p[:amount]} #{p[:currency]} " \
      "(#{p[:status]}) - description: #{p[:description]} - " \
      "created_at: #{p[:created_at]}"
   )
end

# 8 List Customers for this account
log_and_puts(log, stdout_logger, "5️⃣  Listing customers for account…")
raw_customers = client.send(
    :request,
    {
      method:  :get,
      path:    "/v1/customers",
      query:   { account_id: account.id },
      headers: { "Straddle-Account-Id" => account.id }
    }
)
customers = raw_customers[:data]
fail!(log, stdout_logger, "No customers found") if customers.empty?
customers.each do |c|
    log_and_puts(
      log,
      stdout_logger,
      "   • Customer #{c[:id]}: #{c[:first_name]} #{c[:last_name]} " \
      "(email: #{c[:email]}) - created_at: #{c[:created_at]}"
    )
end

log_and_puts(log, stdout_logger, "✅  All tests passed!")













rescue Straddle::Errors::Error => e
  fail!(log, stdout_logger, "API error (#{e.class}): #{e.message}")
end
